# -*- coding: utf-8 -*-
"""
==================
ecs.utils.gpgutils
==================

Encryption/Signing, Decryption/Verifying modul.

- This module uses Gnu Privacy Guard for the actual encryption work
  - The GNU Privacy Guard -- a free implementation of the OpenPGP standard as defined by RFC4880 
  - GnuPG is GPL licensed 
  - Usage in ecs: via commandline wrapper

Usage
=====


 

"""

import os, subprocess
from django.conf import settings
from ecs.utils.pathutils import which

GPG_EXECUTABLE =  settings.ECS_GNUPG if hasattr(settings,"ECS_GNUPG") else which('gpg').next()


def reset_keystore(gpghome):
    ''' wipes out keystore under directory gpghome; Warning: deletes every file in this directory ''' 
    if not os.path.isdir(gpghome):
        os.makedirs(gpghome)
    for f in os.listdir(gpghome):
        path = os.path.join(gpghome, f);
        if os.path.isfile(path):
            os.remove(path)

def gen_keypair(ownername):
    ''' Returns a tuple of ascii armored strings, first is secret key, second is publickey'''
    return NotImplementedError
 
def import_key(keyfile, gpghome):
    ''' import a keyfile (generated by gen_keypair) into gpghome directory gpg keyring '''
    args = [GPG_EXECUTABLE, '--homedir' , gpghome, '--batch', '--yes', '--import', keyfile]
    popen = subprocess.Popen(args, stderr=subprocess.STDOUT, stdout=subprocess.PIPE)
    stdout, empty = popen.communicate()
    returncode = popen.returncode
    if returncode != 0:
        raise IOError('gpg --import returned error code: %d , cmd line was: %s , output was: %s' % (returncode, str(args), stdout))
   
def encrypt_sign(sourcefile, destfile, gpghome, encrypt_owner, signer_owner=None):
    ''' read sourcefile, encrypt and optional sign and write destfile
    @note: booth sourcefile and destfile should already exist (destfile should be zero length)
    @param gpghome: directory where the .gpg files are
    @param encrypt_owner: owner name of key for encryption using his/her public key 
    @param signer_owner: if not None: owner name of key for signing using his/her secret key 
    '''
    args = [GPG_EXECUTABLE, '--homedir', gpghome, '--batch', '--yes', '--always-trust', 
            '--recipient', encrypt_owner, '--output', destfile]
    if signer_owner:
        args += ['--local-user', signer_owner, '--sign']
    args += ['--encrypt', sourcefile]
     
    popen = subprocess.Popen(args, stderr=subprocess.STDOUT, stdout=subprocess.PIPE)
    stdout, empty = popen.communicate()
    returncode = popen.returncode
    if returncode != 0:
        raise IOError('gpg --encrypt returned error code: %d , cmd line was: %s , output was: %s' % (returncode, str(args), stdout))
    
def decrypt_verify(sourcefile, destfile, gpghome, decrypt_owner, verify_owner=None):
    '''
    @param decrypt_owner: owner name of key used for decryption using his/her secret key
    @param verify_owner: owner name of key used for verifying that it was signed using his/her public key
    @raise IOError: on gnupg error, with detailed info
    @raise KeyError: if key owner could not be verified
    '''
    args = [GPG_EXECUTABLE, '--homedir', gpghome, '--batch', '--yes', '--always-trust', 
            '--recipient', decrypt_owner, 
            '--output', destfile, '--decrypt', sourcefile
            ] 
    popen = subprocess.Popen(args, stderr=subprocess.STDOUT, stdout=subprocess.PIPE)
    stdout, empty = popen.communicate()
    returncode = popen.returncode
    if returncode != 0:
        raise IOError('gpg --decrypt returned error code: %d , cmd line was: %s , output was: %s' % (returncode, str(args), stdout))
    
    if verify_owner is not None:
        p = re.compile('gpg: Good signature from "'+ verify_owner+ '"')
        if p.match is None:
            raise KeyError, 'could not verify that signer was keyowner: %s , cmd line was: %s , output was: %s' % (verify_owner, str(args), stdout)
