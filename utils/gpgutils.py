# -*- coding: utf-8 -*-
"""
==================
ecs.utils.gpgutils
==================

Encryption/Signing, Decryption/Verifying modul.

- This module uses Gnu Privacy Guard for the actual encryption work

  - The GNU Privacy Guard -- a free implementation of the OpenPGP standard as defined by RFC4880 
  - GnuPG is GPL licensed 
  - Usage in ecs: via commandline wrapper

Usage
=====


 

"""

import os, subprocess, tempfile, re
from django.conf import settings
from ecs.utils.pathutils import which

GPG_EXECUTABLE =  settings.ECS_GNUPG if hasattr(settings,"ECS_GNUPG") else which('gpg').next()


def reset_keystore(gpghome):
    ''' wipes out keystore under directory gpghome
    
    :warn: deletes every file in this directory
    ''' 
    if not os.path.isdir(gpghome):
        os.makedirs(gpghome)
    for f in os.listdir(gpghome):
        path = os.path.join(gpghome, f);
        if os.path.isfile(path):
            os.remove(path)


def gen_keypair(ownername, secretkey_filename, publickey_filename):
    ''' writes a pair of ascii armored key files, first is secret key, second is publickey, minimum ownername length is five'''
    
    gpghome = tempfile.mkdtemp(dir= settings.TEMPFILE_DIR)
    
    batch_args = "Key-Type: 1\nKey-Length: 2048\nExpire-Date: 0\nName-Real: {0}\n".format(ownername)
    batch_args += "%secring {0}\n%pubring {1}\n".format(secretkey_filename, publickey_filename)
    batch_args += "%commit\n%echo done\n"
    
    args = [GPG_EXECUTABLE, '--homedir' , gpghome, '--batch', '--armor', '--yes', '--gen-key']
    popen = subprocess.Popen(args, stderr=subprocess.STDOUT, stdout=subprocess.PIPE, stdin=subprocess.PIPE)
    stdout, empty = popen.communicate(batch_args)
    popen.stdin.close()
    returncode = popen.returncode
    if returncode != 0:
        raise IOError('gpg --gen-key returned error code: %d , cmd line was: %s , output was: %s' % (returncode, str(args), stdout))

def import_key(keyfile, gpghome):
    ''' import a keyfile (generated by gen_keypair) into gpghome directory gpg keyring '''
    args = [GPG_EXECUTABLE, '--homedir' , gpghome, '--batch', '--yes', '--import', keyfile]
    popen = subprocess.Popen(args, stderr=subprocess.STDOUT, stdout=subprocess.PIPE)
    stdout, empty = popen.communicate()
    returncode = popen.returncode
    if returncode != 0:
        raise IOError('gpg --import returned error code: %d , cmd line was: %s , output was: %s' % (returncode, str(args), stdout))
   
def publickey_list(gpghome):
    ''' returns a string listing all keys in keystore of gpghome '''
    args = [GPG_EXECUTABLE, '--homedir' , gpghome, '--batch', '--yes', '--fixed-list-mode',
        '--with-colons', '--list-keys', '--with-fingerprint', '--with-fingerprint']
    popen = subprocess.Popen(args, stderr=subprocess.PIPE, stdout=subprocess.PIPE)
    stdout, stderr = popen.communicate()
    returncode = popen.returncode
    if returncode != 0:
        raise IOError('gpg --import returned error code: %d , cmd line was: %s , output was: %s' % (returncode, str(args), stdout+ stderr))
    return stdout

def secretkey_list(gpghome):
    ''' returns a string listing all keys in keystore of gpghome '''
    args = [GPG_EXECUTABLE, '--homedir' , gpghome, '--batch', '--yes', '--fixed-list-mode',
        '--with-colons', '--list-secret-keys', '--with-fingerprint', '--with-fingerprint']
    popen = subprocess.Popen(args, stderr=subprocess.PIPE, stdout=subprocess.PIPE)
    stdout, stderr = popen.communicate()
    returncode = popen.returncode
    if returncode != 0:
        raise IOError('gpg --import returned error code: %d , cmd line was: %s , output was: %s' % (returncode, str(args), stdout+ stderr))
    return stdout

def encrypt_sign(sourcefile, destfile, gpghome, encrypt_owner, signer_owner=None):
    ''' read sourcefile, encrypt and optional sign and write destfile
    
    :note: booth sourcefile and destfile should already exist (destfile should be zero length)
    :param gpghome: directory where the .gpg files are
    :param encrypt_owner: owner name of key for encryption using his/her public key 
    :param signer_owner: if not None: owner name of key for signing using his/her secret key 
    '''
    args = [GPG_EXECUTABLE, '--homedir', gpghome, '--batch', '--yes', '--always-trust', 
            '--recipient', encrypt_owner, '--output', destfile]
    if signer_owner:
        args += ['--local-user', signer_owner, '--sign']
    args += ['--encrypt', sourcefile]
     
    popen = subprocess.Popen(args, stderr=subprocess.STDOUT, stdout=subprocess.PIPE)
    stdout, empty = popen.communicate()
    returncode = popen.returncode
    if returncode != 0:
        raise IOError('gpg --encrypt returned error code: %d , cmd line was: %s , output was: %s' % (returncode, str(args), stdout))
    

def decrypt_verify(sourcefile, destfile, gpghome, decrypt_owner, verify_owner=None):
    ''' read sourcefile, decrypt and optional verify if signer is verify_owner
    
    :param decrypt_owner: owner name of key used for decryption using his/her secret key
    :param verify_owner: owner name of key used for verifying that it was signed using his/her public key
    :raise IOError: on gnupg error, with detailed info
    :raise KeyError: if key owner could not be verified
    '''
    args = [GPG_EXECUTABLE, '--homedir', gpghome, '--batch', '--yes', '--always-trust', 
            '--recipient', decrypt_owner, 
            '--output', destfile, '--decrypt', sourcefile
            ] 
    popen = subprocess.Popen(args, stderr=subprocess.STDOUT, stdout=subprocess.PIPE)
    stdout, empty = popen.communicate()
    returncode = popen.returncode
    if returncode != 0:
        raise IOError('gpg --decrypt returned error code: %d , cmd line was: %s , output was: %s' % (returncode, str(args), stdout))
    
    if verify_owner is not None:
        p = re.compile('gpg: Good signature from "'+ verify_owner+ '"')
        if p.match is None:
            raise KeyError, 'could not verify that signer was keyowner: %s , cmd line was: %s , output was: %s' % (verify_owner, str(args), stdout)
